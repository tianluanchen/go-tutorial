import{_ as c}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as l,c as d,a as s,b as n,d as a,w as t,e as o}from"./app-9da01d16.js";const u={},i=s("h1",{id:"_15-2-一个简单的-web-服务器",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#_15-2-一个简单的-web-服务器","aria-hidden":"true"},"#"),n(" 15.2 一个简单的 web 服务器")],-1),r=s("p",null,[n("http 是比 tcp 更高层的协议，它描述了网页服务器如何与客户端浏览器进行通信。Go 提供了 "),s("code",null,"net/http"),n(" 包，我们马上就来看下。先从一些简单的示例开始，首先编写一个“Hello world!”网页服务器："),s("a",{href:"examples/chapter_15/hello_world_webserver.go"},"查看示例 15.6")],-1),h=s("code",null,"http",-1),k=s("code",null,'net.Listen("tcp", "localhost:50000")',-1),v=s("code",null,'http.ListenAndServe("localhost:8080", nil)',-1),_=s("code",null,"localhost",-1),m=s("code",null,"8080",-1),g=s("p",null,[s("code",null,"http.URL"),n(" 用于表示网页地址，其中字符串属性 "),s("code",null,"Path"),n(" 用于保存 url 的路径；"),s("code",null,"http.Request"),n(" 描述了客户端请求，内含一个 "),s("code",null,"URL"),n(" 字段。")],-1),b=s("code",null,"req",-1),f=s("code",null,"“var1”",-1),w=s("code",null,'req.FormValue("var1")',-1),q=s("code",null,"request.ParseForm()",-1),H=s("code",null,'request.Form["var1"]',-1),x=o(`<div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>var1<span class="token punctuation">,</span> found <span class="token operator">:=</span> request<span class="token punctuation">.</span>Form<span class="token punctuation">[</span><span class="token string">&quot;var1&quot;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第二个参数 <code>found</code> 为 <code>true</code>。如果 <code>var1</code> 并未出现在表单中，<code>found</code> 就是 <code>false</code>。</p><p>表单属性实际上是 <code>map[string][]string</code> 类型。网页服务器发送一个 <code>http.Response</code> 响应，它是通过 <code>http.ResponseWriter</code> 对象输出的，后者组装了 HTTP 服务器响应，通过对其写入内容，我们就将数据发送给了 HTTP 客户端。</p><p>现在我们仍然要编写程序，以实现服务器必须做的事，即如何处理请求。这是通过 <code>http.HandleFunc()</code> 函数完成的。在这个例子中，当根路径“/”（url 地址是 <code>http://localhost:8080</code>）被请求的时候（或者这个服务器上的其他任意地址），<code>HelloServer()</code> 函数就被执行了。这个函数是 <code>http.HandlerFunc</code> 类型的，它们通常被命名为 Prefhandler，和某个路径前缀 Pref 匹配。</p><p><code>http.HandleFunc</code> 注册了一个处理函数（这里是 <code>HelloServer()</code>）来处理对应 <code>/</code> 的请求。</p>`,5),F=s("code",null,"/",-1),y=s("code",null,"/create",-1),R=s("code",null,"/edit",-1),S=s("code",null,"ReponseWriter",-1),T=s("code",null,"w",-1),P=s("code",null,"req",-1),L=s("code",null,"w",-1),N=s("code",null,"Hello",-1),W=s("code",null,"r.URL.Path[1:]",-1),A=s("code",null,"[1:]",-1),C=s("code",null,"fmt.Fprintf()",-1),V=s("code",null,'io.WriteString(w, "hello, world!\\n")',-1),B=o(`<p>总结：第一个参数是请求的路径，第二个参数是当路径被请求时，需要调用的处理函数的引用。</p><p>示例 15.6 <a href="examples/chapter_15/hello_world_webserver.go">hello_world_webserver.go</a>：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;log&quot;</span>
	<span class="token string">&quot;net/http&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">HelloServer</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Inside HelloServer handler&quot;</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">&quot;Hello,&quot;</span><span class="token operator">+</span>req<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">,</span> HelloServer<span class="token punctuation">)</span>
	err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">&quot;localhost:8080&quot;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">&quot;ListenAndServe: &quot;</span><span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用命令行启动程序，会打开一个命令窗口显示如下文字：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Starting Process E:/Go/GoBoek/code_examples/chapter_14/hello_world_webserver.exe...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后打开浏览器并输入 url 地址：<code>http://localhost:8080/world</code>，浏览器就会出现文字：<code>Hello, world</code>，网页服务器会响应你在 <code>:8080/</code> 后边输入的内容。</p><p><code>fmt.Println()</code> 在服务器端控制台打印状态；在每个处理函数被调用时，把请求记录下来也许更为有用。</p><p>注：<br> 1）前两行（没有错误处理代码）可以替换成以下写法：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">&quot;:8080&quot;</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span><span class="token function">HandlerFunc</span><span class="token punctuation">(</span>HelloServer<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2）<code>fmt.Fprint()</code> 和 <code>fmt.Fprintf()</code> 都是可以用来写入 <code>http.ResponseWriter</code> 的函数（他们实现了 <code>io.Writer</code>）。</p><p>比如我们可以使用</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">&quot;&lt;h1&gt;%s&lt;/h1&gt;&lt;div&gt;%s&lt;/div&gt;&quot;</span><span class="token punctuation">,</span> title<span class="token punctuation">,</span> body<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>来构建一个非常简单的网页并插入 <code>title</code> 和 <code>body</code> 的值。</p>`,13),E=o(`<p>3）如果你需要使用安全的 https 连接，使用 <code>http.ListenAndServeTLS()</code> 代替 <code>http.ListenAndServe()</code></p><p>4）除了 <code>http.HandleFunc(&quot;/&quot;, Hfunc)</code>，其中的 <code>HFunc</code> 是一个处理函数，签名为：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">HFunc</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以使用这种方式：<code>http.Handle(&quot;/&quot;, http.HandlerFunc(HFunc))</code></p><p><code>HandlerFunc</code> 只是定义了上述 <code>HFunc</code> 签名的别名：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它是一个可以把普通的函数当做 HTTP 处理器 (<code>Handler</code>) 的适配器。如果函数 <code>f</code> 声明得合适，<code>HandlerFunc(f)</code> 就是一个执行 <code>f</code> 函数的 <code>Handler</code> 对象。</p><p><code>http.Handle()</code> 的第二个参数也可以是 <code>T</code> 类型的对象 <code>obj</code>：<code>http.Handle(&quot;/&quot;, obj)</code>。</p><p>如果 <code>T</code> 有 <code>ServeHTTP()</code> 方法，那就实现了 http 的 <code>Handler</code> 接口：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>obj <span class="token operator">*</span>Typ<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,10),G=s("code",null,"Counter",-1),U=s("code",null,"Chan",-1),j=s("code",null,"http.Handler",-1),M=s("code",null,"http",-1),I=o('<p>练习 15.2：<a href="exercises/chapter_15/webhello2.go">webhello2.go</a></p><p>编写一个网页服务器监听端口 9999，有如下处理函数：</p><ul><li><p>当请求 <code>http://localhost:9999/hello/Name</code> 时，响应：<code>hello Name</code>（<code>Name</code> 需是一个合法的姓，比如 Chris 或者 Madeleine）</p></li><li><p>当请求 <code>http://localhost:9999/shouthello/Name</code> 时，响应：<code>hello NAME</code></p></li></ul><p>练习 15.3：<a href="exercises/chapter_15/hello_server.go">hello_server.go</a></p><p>创建一个空结构 <code>hello</code> 并为它实现 <code>http.Handler</code>。运行并测试。</p><h2 id="链接" tabindex="-1"><a class="header-anchor" href="#链接" aria-hidden="true">#</a> 链接</h2>',6);function O(z,D){const e=p("RouterLink");return l(),d("div",null,[i,r,s("p",null,[n("我们引入了 "),h,n(" 包并启动了网页服务器，和 "),a(e,{to:"/the-way-to-go/15.1.html"},{default:t(()=>[n("15.1 节")]),_:1}),n("的 "),k,n(" 函数的 tcp 服务器是类似的，使用 "),v,n(" 函数，如果成功会返回空，否则会返回一个错误（地址 "),_,n(" 部分可以省略，"),m,n(" 是指定的端口号）。")]),g,s("p",null,[n("如果 "),b,n(" 是来自 html 表单的 POST 类型请求，"),f,n(" 是该表单中一个输入域的名称，那么用户输入的值就可以通过 Go 代码 "),w,n(" 获取到（见 "),a(e,{to:"/the-way-to-go/15.4.html"},{default:t(()=>[n("15.4 节")]),_:1}),n("）。还有一种方法是先执行 "),q,n("，然后再获取 "),H,n(" 的第一个返回参数，就像这样：")]),x,s("p",null,[F,n(" 可以被替换为其他更特定的 url，比如 "),y,n("，"),R,n(" 等等；你可以为每一个特定的 url 定义一个单独的处理函数。这个函数需要两个参数：第一个是 "),S,n(" 类型的 "),T,n("；第二个是请求 "),P,n("。程序向 "),L,n(" 写入了 "),N,n(" 和 "),W,n(" 组成的字符串：末尾的 "),A,n(" 表示“创建一个从索引为 1 的字符到结尾的子切片”，用来丢弃路径开头的“/”，"),C,n(" 函数完成了本次写入（见 "),a(e,{to:"/the-way-to-go/12.8.html"},{default:t(()=>[n("12.8 节")]),_:1}),n("）；另一种可行的写法是 "),V,n("。")]),B,s("p",null,[n("如果你需要更多复杂的替换，使用模板包（见 "),a(e,{to:"/the-way-to-go/15.7.html"},{default:t(()=>[n("15.7节")]),_:1}),n("）")]),E,s("p",null,[n("这个用法也在 "),a(e,{to:"/the-way-to-go/15.8.html"},{default:t(()=>[n("15.8 节")]),_:1}),n(),G,n(" 和 "),U,n(" 类型上使用。只要实现了 "),j,n("，"),M,n(" 包就可以处理任何 HTTP 请求。")]),I,s("ul",null,[s("li",null,[a(e,{to:"/the-way-to-go/directory.html"},{default:t(()=>[n("目录")]),_:1})]),s("li",null,[n("上一节："),a(e,{to:"/the-way-to-go/15.1.html"},{default:t(()=>[n("tcp 服务器")]),_:1})]),s("li",null,[n("下一节："),a(e,{to:"/the-way-to-go/15.3.html"},{default:t(()=>[n("访问并读取页面数据")]),_:1})])])])}const Q=c(u,[["render",O],["__file","15.2.html.vue"]]);export{Q as default};
