import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as l,c as i,a as s,b as n,d as e,w as o,e as t}from"./app-9da01d16.js";const u={},r=t(`<h1 id="_14-7-新旧模型对比-任务和-worker" tabindex="-1"><a class="header-anchor" href="#_14-7-新旧模型对比-任务和-worker" aria-hidden="true">#</a> 14.7 新旧模型对比：任务和 worker</h1><p>假设我们需要处理很多任务；一个 worker 处理一项任务。任务可以被定义为一个结构体（具体的细节在这里并不重要）：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> Task <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token comment">// some state</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>旧模式：使用共享内存进行同步</p><p>由各个任务组成的任务池共享内存；为了同步各个 worker 以及避免资源竞争，我们需要对任务池进行加锁保护：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>    <span class="token keyword">type</span> Pool <span class="token keyword">struct</span> <span class="token punctuation">{</span>
        Mu      sync<span class="token punctuation">.</span>Mutex
        Tasks   <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Task
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,6),d=s("code",null,"sync.Mutex",-1),k=s("code",null,"Pool",-1),v=t(`<div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">Worker</span><span class="token punctuation">(</span>pool <span class="token operator">*</span>Pool<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">{</span>
        pool<span class="token punctuation">.</span>Mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// begin critical section:</span>
        task <span class="token operator">:=</span> pool<span class="token punctuation">.</span>Tasks<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token comment">// take the first task</span>
        pool<span class="token punctuation">.</span>Tasks <span class="token operator">=</span> pool<span class="token punctuation">.</span>Tasks<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>  <span class="token comment">// update the pool of tasks</span>
        <span class="token comment">// end critical section</span>
        pool<span class="token punctuation">.</span>Mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token function">process</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些 worker 有许多都可以并发执行；他们可以在 go 协程中启动。一个 worker 先将 <code>pool</code> 锁定，从 <code>pool</code> 获取第一项任务，再解锁和处理任务。加锁保证了同一时间只有一个 go 协程可以进入到 <code>pool</code> 中：一项任务有且只能被赋予一个 worker 。如果不加锁，则工作协程可能会在 <code>task:=pool.Tasks[0]</code> 发生切换，导致 <code>pool.Tasks=pool.Tasks[1:]</code> 结果异常：一些 worker 获取不到任务，而一些任务可能被多个 worker 得到。加锁实现同步的方式在工作协程比较少时可以工作得很好，但是当工作协程数量很大，任务量也很多时，处理效率将会因为频繁的加锁/解锁开销而降低。当工作协程数增加到一个阈值时，程序效率会急剧下降，这就成为了瓶颈。</p><p>新模式：使用通道</p><p>使用通道进行同步：使用一个通道接受需要处理的任务，一个通道接受处理完成的任务（及其结果）。worker 在协程中启动，其数量 <code>N</code> 应该根据任务数量进行调整。</p><p>主线程扮演着 Master 节点角色，可能写成如下形式：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>    <span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pending<span class="token punctuation">,</span> done <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span>Task<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span>Task<span class="token punctuation">)</span>
        <span class="token keyword">go</span> <span class="token function">sendWork</span><span class="token punctuation">(</span>pending<span class="token punctuation">)</span>       <span class="token comment">// put tasks with work on the channel</span>
        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>   <span class="token comment">// start N goroutines to do work</span>
            <span class="token keyword">go</span> <span class="token function">Worker</span><span class="token punctuation">(</span>pending<span class="token punctuation">,</span> done<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token function">consumeWork</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span>          <span class="token comment">// continue with the processed tasks</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>worker 的逻辑比较简单：从 <code>pending</code> 通道拿任务，处理后将其放到 <code>done</code> 通道中：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>    <span class="token keyword">func</span> <span class="token function">Worker</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> out <span class="token keyword">chan</span> <span class="token operator">*</span>Task<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">{</span>
            t <span class="token operator">:=</span> <span class="token operator">&lt;-</span>in
            <span class="token function">process</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
            out <span class="token operator">&lt;-</span> t
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,8),m=s("code",null,"pending",-1),g=s("code",null,"pending",-1),b=t(`<p>从这个简单的例子中可能很难看出第二种模式的优势，但含有复杂锁运用的程序不仅在编写上显得困难，也不容易编写正确，使用第二种模式的话，就无需考虑这么复杂的东西了。</p><p>因此，第二种模式对比第一种模式而言，不仅性能是一个主要优势，而且还有个更大的优势：代码显得更清晰、更优雅。一个更符合 go 语言习惯的 worker 写法：</p><p><strong>IDIOM: Use an in- and out-channel instead of locking</strong></p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>    <span class="token keyword">func</span> <span class="token function">Worker</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> out <span class="token keyword">chan</span> <span class="token operator">*</span>Task<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">{</span>
            t <span class="token operator">:=</span> <span class="token operator">&lt;-</span>in
            <span class="token function">process</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
            out <span class="token operator">&lt;-</span> t
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,4),h=t('<p>怎么选择是该使用锁还是通道？</p><p>通道是一个较新的概念，本节我们着重强调了在 go 协程里通道的使用，但这并不意味着经典的锁方法就不能使用。go 语言让你可以根据实际问题进行选择：创建一个优雅、简单、可读性强、在大多数场景性能表现都能很好的方案。如果你的问题适合使用锁，也不要忌讳使用它。go 语言注重实用，什么方式最能解决你的问题就用什么方式，而不是强迫你使用一种编码风格。下面列出一个普遍的经验法则：</p><ul><li><p>使用锁的情景：</p><ul><li>访问共享数据结构中的缓存信息</li><li>保存应用程序上下文和状态信息数据</li></ul></li><li><p>使用通道的情景：</p><ul><li>与异步操作的结果进行交互</li><li>分发任务</li><li>传递数据所有权</li></ul></li></ul><p>当你发现你的锁使用规则变得很复杂时，可以反省使用通道会不会使问题变得简单些。</p><h2 id="链接" tabindex="-1"><a class="header-anchor" href="#链接" aria-hidden="true">#</a> 链接</h2>',5);function w(f,_){const a=c("RouterLink");return l(),i("div",null,[r,s("p",null,[d,n("（"),e(a,{to:"/the-way-to-go/09.3.html"},{default:o(()=>[n("参见9.3")]),_:1}),n("）是互斥锁：它用来在代码中保护临界区资源：同一时间只有一个 go 协程 (goroutine) 可以进入该临界区。如果出现了同一时间多个 go 协程都进入了该临界区，则会产生竞争："),k,n(" 结构就不能保证被正确更新。在传统的模式中（经典的面向对象的语言中应用得比较多，比如 C++，JAVA，C#），worker 代码可能这样写：")]),v,s("p",null,[n("这里并不使用锁：从通道得到新任务的过程没有任何竞争。随着任务数量增加，worker 数量也应该相应增加，同时性能并不会像第一种方式那样下降明显。在 "),m,n(" 通道中存在一份任务的拷贝，第一个 worker 从 "),g,n(" 通道中获得第一个任务并进行处理，这里并不存在竞争（对一个通道读数据和写数据的整个过程是原子性的：参见 "),e(a,{to:"/the-way-to-go/14.2.html"},{default:o(()=>[n("14.2.2")]),_:1}),n("）。某一个任务会在哪一个 worker 中被执行是不可知的，反过来也是。worker 数量的增多也会增加通信的开销，这会对性能有轻微的影响。")]),b,s("p",null,[n("对于任何可以建模为 Master-Worker 范例的问题，一个类似于 worker 使用通道进行通信和交互、Master 进行整体协调的方案都能完美解决。如果系统部署在多台机器上，各个机器上执行 Worker 协程，Master 和 Worker 之间使用 netchan 或者 RPC 进行通信（参见 "),e(a,{to:"/the-way-to-go/15.0.html"},{default:o(()=>[n("15 章")]),_:1}),n("）。")]),h,s("ul",null,[s("li",null,[e(a,{to:"/the-way-to-go/directory.html"},{default:o(()=>[n("目录")]),_:1})]),s("li",null,[n("上一节："),e(a,{to:"/the-way-to-go/14.6.html"},{default:o(()=>[n("协程和恢复（recover）")]),_:1})]),s("li",null,[n("下一节："),e(a,{to:"/the-way-to-go/14.8.html"},{default:o(()=>[n("惰性生成器实现")]),_:1})])])])}const T=p(u,[["render",w],["__file","14.7.html.vue"]]);export{T as default};
