import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as i,c as l,a as s,b as n,d as e,w as t,e as p}from"./app-9da01d16.js";const u={},d=p(`<h1 id="_11-12-接口与动态类型" tabindex="-1"><a class="header-anchor" href="#_11-12-接口与动态类型" aria-hidden="true">#</a> 11.12 接口与动态类型</h1><h2 id="_11-12-1-go-的动态类型" tabindex="-1"><a class="header-anchor" href="#_11-12-1-go-的动态类型" aria-hidden="true">#</a> 11.12.1 Go 的动态类型</h2><p>在经典的面向对象语言（像 C++，Java 和 C#）中数据和方法被封装为<em>类</em>的概念：类包含它们两者，并且不能剥离。</p><p>Go 没有类：数据（结构体或更一般的类型）和方法是一种松耦合的正交关系。</p><p>Go 中的接口跟 Java/C# 类似：都是必须提供一个指定方法集的实现。但是更加灵活通用：任何提供了接口方法实现代码的类型都隐式地实现了该接口，而不用显式地声明。</p><p>和其它语言相比，Go 是唯一结合了接口值，静态类型检查（是否该类型实现了某个接口），运行时动态转换的语言，并且不需要显式地声明类型是否满足某个接口。该特性允许我们在不改变已有的代码的情况下定义和使用新接口。</p><p>接收一个（或多个）接口类型作为参数的函数，其<strong>实参</strong>可以是任何实现了该接口的类型的变量。 <em>实现了某个接口的类型可以被传给任何以此接口为参数的函数</em>。</p><p>类似于 Python 和 Ruby 这类动态语言中的动态类型 (duck typing)；这意味着对象可以根据提供的方法被处理（例如，作为参数传递给函数），而忽略它们的实际类型：它们能做什么比它们是什么更重要。</p><p>这在程序 <a href="examples/chapter_11/duck_dance.go">duck_dance.go</a> 中得以阐明，函数 <code>DuckDance()</code> 接受一个 <code>IDuck</code> 接口类型变量。仅当 <code>DuckDance()</code> 被实现了 <code>IDuck</code> 接口的类型调用时程序才能编译通过。</p><p>示例 11.16 <a href="examples/chapter_11/duck_dance.go">duck_dance.go</a>：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">type</span> IDuck <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">Walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">DuckDance</span><span class="token punctuation">(</span>duck IDuck<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		duck<span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		duck<span class="token punctuation">.</span><span class="token function">Walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Bird <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Bird<span class="token punctuation">)</span> <span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;I am quacking!&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Bird<span class="token punctuation">)</span> <span class="token function">Walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;I am walking!&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	b <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>Bird<span class="token punctuation">)</span>
	<span class="token function">DuckDance</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>I am quacking!
I am walking!
I am quacking!
I am walking!
I am quacking!
I am walking!
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果 <code>Bird</code> 没有实现 <code>Walk()</code>（把它注释掉），会得到一个编译错误：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>cannot use b (type *Bird) as type IDuck in function argument:
*Bird does not implement IDuck (missing Walk method)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果对 <code>cat</code> 调用函数 <code>DuckDance()</code>，Go 会提示编译错误，但是 Python 和 Ruby 会以运行时错误结束。</p><h2 id="_11-12-2-动态方法调用" tabindex="-1"><a class="header-anchor" href="#_11-12-2-动态方法调用" aria-hidden="true">#</a> 11.12.2 动态方法调用</h2><p>像 Python，Ruby 这类语言，动态类型是延迟绑定的（在运行时进行）：方法只是用参数和变量简单地调用，然后在运行时才解析（它们很可能有像 <code>responds_to</code> 这样的方法来检查对象是否可以响应某个方法，但是这也意味着更大的编码量和更多的测试工作）</p>`,18),r=s("code",null,"interface{}",-1),k=p(`<p>例如，你用不同的类型表示 XML 输出流中的不同实体。然后我们为 XML 定义一个如下的“写”接口（甚至可以把它定义为私有接口）：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> xmlWriter <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token function">WriteXML</span><span class="token punctuation">(</span>w io<span class="token punctuation">.</span>Writer<span class="token punctuation">)</span> <span class="token builtin">error</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们可以实现适用于该流类型的任何变量的 <code>StreamXML()</code> 函数，并用类型断言检查传入的变量是否实现了该接口；如果没有，我们就调用内建的 <code>encodeToXML()</code> 来完成相应工作：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token comment">// Exported XML streaming function.</span>
<span class="token keyword">func</span> <span class="token function">StreamXML</span><span class="token punctuation">(</span>v <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> w io<span class="token punctuation">.</span>Writer<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> xw<span class="token punctuation">,</span> ok <span class="token operator">:=</span> v<span class="token punctuation">.</span><span class="token punctuation">(</span>xmlWriter<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>
		<span class="token comment">// It’s an  xmlWriter, use method of asserted type.</span>
		<span class="token keyword">return</span> xw<span class="token punctuation">.</span><span class="token function">WriteXML</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// No implementation, so we have to use our own function (with perhaps reflection):</span>
	<span class="token keyword">return</span> <span class="token function">encodeToXML</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> w<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// Internal XML encoding function.</span>
<span class="token keyword">func</span> <span class="token function">encodeToXML</span><span class="token punctuation">(</span>v <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> w io<span class="token punctuation">.</span>Writer<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Go 在这里用了和 <code>gob</code> 相同的机制：定义了两个接口 <code>GobEncoder</code> 和 <code>GobDecoder</code>。这样就允许类型自己实现从流编解码的具体方式；如果没有实现就使用标准的反射方式。</p><p>因此 Go 提供了动态语言的优点，却没有其他动态语言在运行时可能发生错误的缺点。</p><p>对于动态语言非常重要的单元测试来说，这样即可以减少单元测试的部分需求，又可以发挥相当大的作用。</p><p>Go 的接口提高了代码的分离度，改善了代码的复用性，使得代码开发过程中的设计模式更容易实现。用 Go 接口还能实现“依赖注入模式”。</p><h2 id="_11-12-3-接口的提取" tabindex="-1"><a class="header-anchor" href="#_11-12-3-接口的提取" aria-hidden="true">#</a> 11.12.3 接口的提取</h2><p><em>提取接口</em>是非常有用的设计模式，可以减少需要的类型和方法数量，而且不需要像传统的基于类的面向对象语言那样维护整个的类层次结构。</p><p>Go 接口可以让开发者找出自己写的程序中的类型。假设有一些拥有共同行为的对象，并且开发者想要抽象出这些行为，这时就可以创建一个接口来使用。</p><p>我们来扩展 11.1 节的示例 11.2 <a href="examples/chapter_11/interfaces_poly.go">interfaces_poly.go</a>，假设我们需要一个新的接口 <code>TopologicalGenus</code>，用来给 <code>shape</code> 排序（这里简单地实现为返回 <code>int</code>）。我们需要做的是给想要满足接口的类型实现 <code>Rank()</code> 方法：</p><p>示例 11.17 <a href="examples/chapter_11/multi_interfaces_poly.go">multi_interfaces_poly.go</a>：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token comment">//multi_interfaces_poly.go</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">type</span> Shaper <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float32</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> TopologicalGenus <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token function">Rank</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Square <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	side <span class="token builtin">float32</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>sq <span class="token operator">*</span>Square<span class="token punctuation">)</span> <span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float32</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> sq<span class="token punctuation">.</span>side <span class="token operator">*</span> sq<span class="token punctuation">.</span>side
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>sq <span class="token operator">*</span>Square<span class="token punctuation">)</span> <span class="token function">Rank</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token number">1</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Rectangle <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	length<span class="token punctuation">,</span> width <span class="token builtin">float32</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>r Rectangle<span class="token punctuation">)</span> <span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float32</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> r<span class="token punctuation">.</span>length <span class="token operator">*</span> r<span class="token punctuation">.</span>width
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>r Rectangle<span class="token punctuation">)</span> <span class="token function">Rank</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token number">2</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	r <span class="token operator">:=</span> Rectangle<span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span> <span class="token comment">// Area() of Rectangle needs a value</span>
	q <span class="token operator">:=</span> <span class="token operator">&amp;</span>Square<span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">}</span>      <span class="token comment">// Area() of Square needs a pointer</span>
	shapes <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>Shaper<span class="token punctuation">{</span>r<span class="token punctuation">,</span> q<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Looping through shapes for area ...&quot;</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> n<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> <span class="token keyword">range</span> shapes <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Shape details: &quot;</span><span class="token punctuation">,</span> shapes<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Area of this shape is: &quot;</span><span class="token punctuation">,</span> shapes<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	topgen <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>TopologicalGenus<span class="token punctuation">{</span>r<span class="token punctuation">,</span> q<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Looping through topgen for rank ...&quot;</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> n<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> <span class="token keyword">range</span> topgen <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Shape details: &quot;</span><span class="token punctuation">,</span> topgen<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Topological Genus of this shape is: &quot;</span><span class="token punctuation">,</span> topgen<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Rank</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Looping through shapes for area ...
Shape details:  {5 3}
Area of this shape is:  15
Shape details:  &amp;{5}
Area of this shape is:  25
Looping through topgen for rank ...
Shape details:  {5 3}
Topological Genus of this shape is:  2
Shape details:  &amp;{5}
Topological Genus of this shape is:  1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以你不用提前设计出所有的接口；<em>整个设计可以持续演进，而不用废弃之前的决定</em>。类型要实现某个接口，它本身不用改变，你只需要在这个类型上实现新的方法。</p><h2 id="_11-12-4-显式地指明类型实现了某个接口" tabindex="-1"><a class="header-anchor" href="#_11-12-4-显式地指明类型实现了某个接口" aria-hidden="true">#</a> 11.12.4 显式地指明类型实现了某个接口</h2><p>如果你希望满足某个接口的类型显式地声明它们实现了这个接口，你可以向接口的方法集中添加一个具有描述性名字的方法。例如：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> Fooer <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">ImplementsFooer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>类型 Bar 必须实现 <code>ImplementsFooer</code> 方法来满足 <code>Fooer</code> 接口，以清楚地记录这个事实。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> Bar <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>b Bar<span class="token punctuation">)</span> <span class="token function">ImplementsFooer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>b Bar<span class="token punctuation">)</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>大部分代码并不使用这样的约束，因为它限制了接口的实用性。</p><p>但是有些时候，这样的约束在大量相似的接口中被用来解决歧义。</p><h2 id="_11-12-5-空接口和函数重载" tabindex="-1"><a class="header-anchor" href="#_11-12-5-空接口和函数重载" aria-hidden="true">#</a> 11.12.5 空接口和函数重载</h2>`,25),v=s("code",null,"...T",-1),m=s("code",null,"T",-1),b=s("code",null,"T",-1),g=p(`<p>函数 <code>fmt.Printf</code> 就是这样做的：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span>format <span class="token builtin">string</span><span class="token punctuation">,</span> a <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> errno <span class="token builtin">error</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,2),f=s("code",null,"String()",-1),h=p(`<h2 id="_11-12-6-接口的继承" tabindex="-1"><a class="header-anchor" href="#_11-12-6-接口的继承" aria-hidden="true">#</a> 11.12.6 接口的继承</h2><p>当一个类型包含（内嵌）另一个类型（实现了一个或多个接口）的指针时，这个类型就可以使用（另一个类型）所有的接口方法。</p><p>例如：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> Task <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Command <span class="token builtin">string</span>
	<span class="token operator">*</span>log<span class="token punctuation">.</span>Logger
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个类型的工厂方法像这样：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">NewTask</span><span class="token punctuation">(</span>command <span class="token builtin">string</span><span class="token punctuation">,</span> logger <span class="token operator">*</span>log<span class="token punctuation">.</span>Logger<span class="token punctuation">)</span> <span class="token operator">*</span>Task <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>Task<span class="token punctuation">{</span>command<span class="token punctuation">,</span> logger<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 <code>log.Logger</code> 实现了 <code>Log()</code> 方法后，<code>Task</code> 的实例 <code>task</code> 就可以调用该方法：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>task<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>类型可以通过继承多个接口来提供像<em>多重继承</em>一样的特性：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> ReaderWriter <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token operator">*</span>io<span class="token punctuation">.</span>Reader
	<span class="token operator">*</span>io<span class="token punctuation">.</span>Writer
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,10),_=p(`<p>有用的接口可以在开发的过程中被归纳出来。添加新接口非常容易，因为已有的类型不用变动（仅仅需要实现新接口的方法）。已有的函数可以扩展为使用接口类型的约束性参数：通常只有函数签名需要改变。对比基于类的 OO 类型的语言在这种情况下则需要适应整个类层次结构的变化。</p><p><strong>练习 11.11</strong>：<a href="exercises/chapter_11/map_function_interface.go">map_function_interface.go</a>：</p><p>在练习 7.13 中我们定义了一个 <code>map()</code> 函数来使用 <code>int</code> 切片 (<a href="exercises/chapter_7/map_function.go">map_function.go</a>)。</p><p>通过空接口和类型断言，现在我们可以写一个可以应用于许多类型的<em>泛型</em>的 <code>map()</code> 函数，为 <code>int</code> 和 <code>string</code> 构建一个把 <code>int</code> 值加倍和将字符串值与其自身连接（译者注：即 <code>&quot;abc&quot;</code> 变成 <code>&quot;abcabc&quot;</code> ）的 <code>map()</code> 函数 <code>mapFunc()</code>。</p><p>提示：为了可读性可以定义一个 <code>interface{}</code> 的别名，比如：<code>type obj interface{}</code>。</p><p><strong>练习 11.12</strong>：<a href="exercises/chapter_11/map_function_interface_var.go">map_function_interface_var.go</a>：</p><p>稍微改变练习 11.11，允许 <code>mapFunc()</code> 接收不定数量的 <code>items</code>。</p><p><strong>练习 11.13</strong>：<a href="exercises/chapter_11/main_stack.go">main_stack.go</a>—<a href="exercises/chapter_11/stack/stack_general.go">stack/stack_general.go</a>：</p><p>在练习 10.16 和 10.17 中我们开发了一些栈结构类型。但是它们被限制为某种固定的内建类型。现在用一个元素类型是 <code>interface{}</code>（空接口）的切片开发一个通用的栈类型。</p><p>实现下面的栈方法：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
<span class="token function">IsEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>
<span class="token function">Push</span><span class="token punctuation">(</span>x <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Pop()</code> 改变栈并返回最顶部的元素；<code>Top()</code> 只返回最顶部元素。</p><p>在主程序中构建一个充满不同类型元素的栈，然后弹出并打印所有元素的值。</p><h2 id="链接" tabindex="-1"><a class="header-anchor" href="#链接" aria-hidden="true">#</a> 链接</h2>`,14);function y(w,x){const a=c("RouterLink");return i(),l("div",null,[d,s("p",null,[n("Go 的实现与此相反，通常需要编译器静态检查的支持：当变量被赋值给一个接口类型的变量时，编译器会检查其是否实现了该接口的所有函数。如果方法调用作用于像 "),r,n(" 这样的“泛型”上，你可以通过类型断言（参见 "),e(a,{to:"/the-way-to-go/11.3.html"},{default:t(()=>[n("11.3")]),_:1}),n(" 节）来检查变量是否实现了相应接口。")]),k,s("p",null,[n("在 "),e(a,{to:"/the-way-to-go/06.1.html"},{default:t(()=>[n("6.1")]),_:1}),n(" 节中, 我们看到函数重载是不被允许的。在 Go 语言中函数重载可以用可变参数 "),v,n(" 作为函数最后一个参数来实现（参见 "),e(a,{to:"/the-way-to-go/06.3.html"},{default:t(()=>[n("6.3")]),_:1}),n(" 节）。如果我们把 "),m,n(" 换为空接口，那么可以知道任何类型的变量都是满足 "),b,n(" (空接口）类型的，这样就允许我们传递任何数量任何类型的参数给函数，即重载的实际含义。")]),g,s("p",null,[n("这个函数通过枚举 slice 类型的实参动态确定所有参数的类型，并查看每个类型是否实现了 "),f,n(" 方法，如果是就用于产生输出信息。我们可以回到 "),e(a,{to:"/the-way-to-go/11.10.html"},{default:t(()=>[n("11.10")]),_:1}),n(" 节查看这些细节。")]),h,s("p",null,[n("上面概述的原理被应用于整个 Go 包，多态用得越多，代码就相对越少（参见 "),e(a,{to:"/the-way-to-go/12.8.html"},{default:t(()=>[n("12.8 节")]),_:1}),n("）。这被认为是 Go 编程中的重要的最佳实践。")]),_,s("ul",null,[s("li",null,[e(a,{to:"/the-way-to-go/directory.html"},{default:t(()=>[n("目录")]),_:1})]),s("li",null,[n("上一节："),e(a,{to:"/the-way-to-go/11.11.html"},{default:t(()=>[n("Printf 和反射")]),_:1})]),s("li",null,[n("下一节："),e(a,{to:"/the-way-to-go/11.13.html"},{default:t(()=>[n("总结：Go 中的面向对象")]),_:1})])])])}const L=o(u,[["render",y],["__file","11.12.html.vue"]]);export{L as default};
