import{_ as d}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as u,c as _,a as l,b as e,d as o,w as n,e as s}from"./app-9da01d16.js";const a={},h=s('<h1 id="_6-5-内置函数" tabindex="-1"><a class="header-anchor" href="#_6-5-内置函数" aria-hidden="true">#</a> 6.5 内置函数</h1><p>Go 语言拥有一些不需要进行导入操作就可以使用的内置函数。它们有时可以针对不同的类型进行操作，例如：<code>len()</code>、<code>cap()</code> 和 <code>append()</code>，或必须用于系统级的操作，例如：<code>panic()</code>。因此，它们需要直接获得编译器的支持。</p><p>以下是一个简单的列表，我们会在后面的章节中对它们进行逐个深入的讲解。</p>',3),i=l("thead",null,[l("tr",null,[l("th",null,"名称"),l("th",null,"说明")])],-1),r=l("tr",null,[l("td",null,[l("code",null,"close()")]),l("td",null,"用于管道通信")],-1),m=l("tr",null,[l("td",null,[l("code",null,"len()"),e("、"),l("code",null,"cap()")]),l("td",null,[l("code",null,"len()"),e(" 用于返回某个类型的长度或数量（字符串、数组、切片、"),l("code",null,"map"),e(" 和管道）；"),l("code",null,"cap()"),e(" 是容量的意思，用于返回某个类型的最大容量（只能用于数组、切片和管道，不能用于 "),l("code",null,"map"),e("）")])],-1),p=l("td",null,[l("code",null,"new()"),e("、"),l("code",null,"make()")],-1),f=l("code",null,"new()",-1),w=l("code",null,"make()",-1),y=l("code",null,"new()",-1),g=l("code",null,"make",-1),k=l("code",null,"map",-1),x=l("code",null,"new(type)",-1),T=l("code",null,"make(type)",-1),b=l("code",null,"new(T)",-1),v=l("code",null,"T",-1),N=l("code",null,"T",-1),V=l("code",null,"v := new(int)",-1),B=l("code",null,"make(T)",-1),C=l("code",null,"T",-1),L=l("code",null,"new()",-1),R=l("strong",null,[l("code",null,"new()"),e(" 是一个函数，不要忘记它的括号")],-1),E=l("tr",null,[l("td",null,[l("code",null,"copy()"),e("、"),l("code",null,"append()")]),l("td",null,"用于复制和连接切片")],-1),G=l("tr",null,[l("td",null,[l("code",null,"panic()"),e("、"),l("code",null,"recover()")]),l("td",null,"两者均用于错误处理机制")],-1),S=l("td",null,[l("code",null,"print()"),e("、"),l("code",null,"println()")],-1),j=l("code",null,"fmt",-1),q=l("td",null,[l("code",null,"complex()"),e("、"),l("code",null,"real ()"),e("、"),l("code",null,"imag()")],-1),z=l("h2",{id:"链接",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#链接","aria-hidden":"true"},"#"),e(" 链接")],-1);function A(D,F){const t=c("RouterLink");return u(),_("div",null,[h,l("table",null,[i,l("tbody",null,[r,m,l("tr",null,[p,l("td",null,[f,e(" 和 "),w,e(" 均是用于分配内存："),y,e(" 用于值类型和用户定义的类型，如自定义结构，"),g,e(" 用于内置引用类型（切片、"),k,e(" 和管道）。它们的用法就像是函数，但是将类型作为参数："),x,e("、"),T,e("。"),b,e(" 分配类型 "),v,e(" 的零值并返回其地址，也就是指向类型 "),N,e(" 的指针（详见"),o(t,{to:"/the-way-to-go/10.1.html"},{default:n(()=>[e("第 10.1 节")]),_:1}),e("）。它也可以被用于基本类型："),V,e("。"),B,e(" 返回类型 "),C,e(" 的初始化之后的值，因此它比 "),L,e(" 进行更多的工作（详见"),o(t,{to:"/the-way-to-go/07.2.html"},{default:n(()=>[e("第 7.2.3/4 节")]),_:1}),e("、"),o(t,{to:"/the-way-to-go/08.1.html"},{default:n(()=>[e("第 8.1.1 节")]),_:1}),e("和"),o(t,{to:"/the-way-to-go/14.2.html"},{default:n(()=>[e("第 14.2.1 节")]),_:1}),e("）。"),R,e("。")])]),E,G,l("tr",null,[S,l("td",null,[e("底层打印函数（详见"),o(t,{to:"/the-way-to-go/04.2.html"},{default:n(()=>[e("第 4.2 节")]),_:1}),e("），在部署环境中建议使用 "),j,e(" 包")])]),l("tr",null,[q,l("td",null,[e("用于创建和操作复数（详见"),o(t,{to:"/the-way-to-go/04.5.html"},{default:n(()=>[e("第 4.5.2.2 节")]),_:1}),e("）")])])])]),z,l("ul",null,[l("li",null,[o(t,{to:"/the-way-to-go/directory.html"},{default:n(()=>[e("目录")]),_:1})]),l("li",null,[e("上一节："),o(t,{to:"/the-way-to-go/06.4.html"},{default:n(()=>[e("defer 和追踪")]),_:1})]),l("li",null,[e("下一节："),o(t,{to:"/the-way-to-go/06.6.html"},{default:n(()=>[e("递归函数")]),_:1})])])])}const J=d(a,[["render",A],["__file","06.5.html.vue"]]);export{J as default};
