import{_ as c}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as l,c as d,a as n,b as a,d as s,w as o,e as t}from"./app-9da01d16.js";const i={},r=t(`<h1 id="版本-4-用-json-持久化存储" tabindex="-1"><a class="header-anchor" href="#版本-4-用-json-持久化存储" aria-hidden="true">#</a> 版本 4 - 用 JSON 持久化存储</h1><p>第 4 个版本的代码 <em>goto_v4</em> 见 <a href="examples/chapter_19/goto_v4">goto_v4</a>。</p><h1 id="_19-7-以-json-格式存储" tabindex="-1"><a class="header-anchor" href="#_19-7-以-json-格式存储" aria-hidden="true">#</a> 19.7 以 json 格式存储</h1><p>如果你是个敏锐的测试者也许已经注意到了，当 goto 程序启动 2 次，第 2 次启动后能读取短 URL 且完美地工作。然而从第 3 次开始，会得到错误：</p><pre><code>Error loading URLStore: extra data in buffer
</code></pre>`,5),u=n("code",null,"load()",-1),g=n("code",null,"saveLoop()",-1),h=t(`<p>从创建新的空文件 store.json 开始，更改 main.go 中声明文件名变量的那一行：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">var</span> dataFile <span class="token operator">=</span> flag<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token string">&quot;file&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;store.json&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;data store file name&quot;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在 store.go 中导入 <code>json</code> 取代 <code>gob</code>。然后在 <code>saveLoop()</code> 中唯一需要被修改的行：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>e <span class="token operator">:=</span> gob<span class="token punctuation">.</span><span class="token function">NewEncoder</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>更改为：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>e <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">NewEncoder</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>类似的，在 <code>load</code> 方法中：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>d <span class="token operator">:=</span> gob<span class="token punctuation">.</span><span class="token function">NewDecoder</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>修改为：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>d <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">NewDecoder</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这就是所有要改动的地方！编译，启动并测试，你会发现之前的错误不会再发生了。</p><h2 id="链接" tabindex="-1"><a class="header-anchor" href="#链接" aria-hidden="true">#</a> 链接</h2>`,12);function m(v,k){const e=p("RouterLink");return l(),d("div",null,[r,n("p",null,[a("这是由于 gob 是基于流的协议，它不支持重新开始。为补救该问题，这里我们使用 json 作为存储协议（见 "),s(e,{to:"/the-way-to-go/12.9.html"},{default:o(()=>[a("12.9 节")]),_:1}),a("），它以纯文本形式存储数据，因此也可以被非 Go 语言编写的进程读取。同时也显示了更换一种不同的持久化协议是多么简单，因为与存储打交道的代码被清晰地隔离在 2 个方法中，即 "),u,a(" 和 "),g,a("。")]),h,n("ul",null,[n("li",null,[s(e,{to:"/the-way-to-go/directory.html"},{default:o(()=>[a("目录")]),_:1})]),n("li",null,[a("上一节："),s(e,{to:"/the-way-to-go/19.6.html"},{default:o(()=>[a("用协程优化性能")]),_:1})]),n("li",null,[a("下一节："),s(e,{to:"/the-way-to-go/19.8.html"},{default:o(()=>[a("多服务器处理架构")]),_:1})])])])}const b=c(i,[["render",m],["__file","19.7.html.vue"]]);export{b as default};
