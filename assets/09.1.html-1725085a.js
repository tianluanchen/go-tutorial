import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as d,c as p,a as n,b as e,d as o,w as l,e as t}from"./app-9da01d16.js";const u={},r=n("h1",{id:"_9-1-标准库概述",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_9-1-标准库概述","aria-hidden":"true"},"#"),e(" 9.1 标准库概述")],-1),_=n("code",null,"fmt",-1),h=n("code",null,"os",-1),m={href:"https://gowalker.org/search?q=gorepos",target:"_blank",rel:"noopener noreferrer"},k=t(`<p>在贯穿本书的例子和练习中，我们都是用标准库的包。可以通过查阅第 350 页包中的内容快速找到相关的包的实例。这里我们只是按功能进行分组来介绍这些包的简单用途，我们不会深入讨论他们的内部结构。</p><ul><li><code>unsafe</code>: 包含了一些打破 Go 语言“类型安全”的命令，一般的程序中不会被使用，可用在 C/C++ 程序的调用中。</li><li><code>syscall</code>-<code>os</code>-<code>os/exec</code>: <ul><li><code>os</code>: 提供给我们一个平台无关性的操作系统功能接口，采用类 Unix 设计，隐藏了不同操作系统间的差异，让不同的文件系统和操作系统对象表现一致。</li><li><code>os/exec</code>: 提供我们运行外部操作系统命令和程序的方式。</li><li><code>syscall</code>: 底层的外部包，提供了操作系统底层调用的基本接口。</li></ul></li></ul><p>通过一个 Go 程序让Linux重启来体现它的能力。</p><p>示例 9.1 <a href="examples/chapter_9/reboot.go">reboot.go</a>：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">package</span> main
<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;syscall&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">const</span> LINUX_REBOOT_MAGIC1 <span class="token builtin">uintptr</span> <span class="token operator">=</span> <span class="token number">0xfee1dead</span>
<span class="token keyword">const</span> LINUX_REBOOT_MAGIC2 <span class="token builtin">uintptr</span> <span class="token operator">=</span> <span class="token number">672274793</span>
<span class="token keyword">const</span> LINUX_REBOOT_CMD_RESTART <span class="token builtin">uintptr</span> <span class="token operator">=</span> <span class="token number">0x1234567</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	syscall<span class="token punctuation">.</span><span class="token function">Syscall</span><span class="token punctuation">(</span>syscall<span class="token punctuation">.</span>SYS_REBOOT<span class="token punctuation">,</span>
		LINUX_REBOOT_MAGIC1<span class="token punctuation">,</span>
		LINUX_REBOOT_MAGIC2<span class="token punctuation">,</span>
		LINUX_REBOOT_CMD_RESTART<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>archive/tar</code> 和 <code>/zip-compress</code>：压缩（解压缩）文件功能。</li><li><code>fmt</code>-<code>io</code>-<code>bufio</code>-<code>path/filepath</code>-<code>flag</code>: <ul><li><code>fmt</code>: 提供了格式化输入输出功能。</li><li><code>io</code>: 提供了基本输入输出功能，大多数是围绕系统功能的封装。</li><li><code>bufio</code>: 缓冲输入输出功能的封装。</li><li><code>path/filepath</code>: 用来操作在当前系统中的目标文件名路径。</li><li><code>flag</code>: 对命令行参数的操作。</li></ul></li><li><code>strings</code>-<code>strconv</code>-<code>unicode</code>-<code>regexp</code>-<code>bytes</code>: <ul><li><code>strings</code>: 提供对字符串的操作。</li><li><code>strconv</code>: 提供将字符串转换为基础类型的功能。</li><li><code>unicode</code>: 为 unicode 型的字符串提供特殊的功能。</li><li><code>regexp</code>: 正则表达式功能。</li><li><code>bytes</code>: 提供对字符型分片的操作。</li><li><code>index/suffixarray</code>: 子字符串快速查询。</li></ul></li><li><code>math</code>-<code>math/cmath</code>-<code>math/big</code>-<code>math/rand</code>-<code>sort</code>: <ul><li><code>math</code>: 基本的数学函数。</li><li><code>math/cmath</code>: 对复数的操作。</li><li><code>math/rand</code>: 伪随机数生成。</li><li><code>sort</code>: 为数组排序和自定义集合。</li><li><code>math/big</code>: 大数的实现和计算。</li></ul></li><li><code>container</code>-<code>/list-ring-heap</code>: 实现对集合的操作。 <ul><li><code>list</code>: 双链表。</li><li><code>ring</code>: 环形链表。</li></ul></li></ul><p>下面代码演示了如何遍历一个链表(当 l 是 <code>*List</code>)：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">for</span> e <span class="token operator">:=</span> l<span class="token punctuation">.</span><span class="token function">Front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">//do something with e.Value</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,8),g=n("li",null,[n("code",null,"time"),e("-"),n("code",null,"log"),e(": "),n("ul",null,[n("li",null,[n("code",null,"time"),e(": 日期和时间的基本操作。")]),n("li",null,[n("code",null,"log"),e(": 记录程序运行时产生的日志，我们将在后面的章节使用它。")])])],-1),v=n("code",null,"encoding/json",-1),f=n("code",null,"encoding/xml",-1),b=n("code",null,"text/template",-1),x=n("li",null,[n("code",null,"encoding/json"),e(": 读取并解码和写入并编码 JSON 数据。")],-1),y=n("code",null,"encoding/xml",-1),w=n("code",null,"text/template",-1),T=n("code",null,"net",-1),L=n("code",null,"net/http",-1),O=n("code",null,"html",-1),N=n("ul",null,[n("li",null,[n("code",null,"net"),e(": 网络数据的基本操作。")]),n("li",null,[n("code",null,"http"),e(": 提供了一个可扩展的 HTTP 服务器和基础客户端，解析 HTTP 请求和回复。")]),n("li",null,[n("code",null,"html"),e(": HTML5 解析器。")])],-1),R=n("li",null,[n("code",null,"runtime"),e(": Go 程序运行时的交互操作，例如垃圾回收和协程创建。")],-1),E=n("li",null,[n("code",null,"reflect"),e(": 实现通过程序运行时反射，让程序操作任意类型的变量。")],-1),I=t('<p><code>exp</code> 包中有许多将被编译为新包的实验性的包。在下次稳定版本发布的时候，它们将成为独立的包。如果前一个版本已经存在了，它们将被作为过时的包被回收。然而 Go1.0 发布的时候并没有包含过时或者实验性的包。</p><p><strong>练习 9.1</strong> <a href="exercises/chapter_9/dlinked_list.go">Q20_linked_list.go</a></p><p>使用 <code>container/list</code> 包实现一个双向链表，将 <code>101</code>、<code>102</code> 和 <code>103</code> 放入其中并打印出来。</p><p><strong>练习 9.2</strong> <a href="exercises/chapter_9/size_int.go">size_int.go</a></p><p>通过使用 <code>unsafe</code> 包中的方法来测试你电脑上一个整型变量占用多少个字节。</p><h2 id="链接" tabindex="-1"><a class="header-anchor" href="#链接" aria-hidden="true">#</a> 链接</h2>',6);function G(B,C){const c=a("ExternalLinkIcon"),s=a("RouterLink");return d(),p("div",null,[r,n("p",null,[e("像 "),_,e("、"),h,e(" 等这样具有常用功能的内置包在 Go 语言中有 150 个以上，它们被称为标准库，大部分(一些底层的除外)内置于 Go 本身。完整列表可以在 "),n("a",m,[e("Go Walker"),o(c)]),e(" 查看。")]),k,n("ul",null,[g,n("li",null,[v,e("-"),f,e("-"),b,e(": "),n("ul",null,[x,n("li",null,[y,e(": 简单的 XML1.0 解析器，有关 JSON 和 XML 的实例请查阅第 "),o(s,{to:"/the-way-to-go/12.9.html"},{default:l(()=>[e("12.9")]),_:1}),e("/"),o(s,{to:"/the-way-to-go/10.0.html"},{default:l(()=>[e("10")]),_:1}),e(" 章节。")]),n("li",null,[w,e(":生成像 HTML 一样的数据与文本混合的数据驱动模板（参见"),o(s,{to:"/the-way-to-go/15.7.html"},{default:l(()=>[e("第 15.7 节")]),_:1}),e("）。")])])]),n("li",null,[T,e("-"),L,e("-"),O,e(":（参见"),o(s,{to:"/the-way-to-go/15.0.html"},{default:l(()=>[e("第 15 章")]),_:1}),e("） "),N]),R,E]),I,n("ul",null,[n("li",null,[o(s,{to:"/the-way-to-go/directory.html"},{default:l(()=>[e("目录")]),_:1})]),n("li",null,[e("上一节："),o(s,{to:"/the-way-to-go/09.0.html"},{default:l(()=>[e("包 (package)")]),_:1})]),n("li",null,[e("下一节："),o(s,{to:"/the-way-to-go/09.2.html"},{default:l(()=>[e("regexp 包")]),_:1})])])])}const X=i(u,[["render",G],["__file","09.1.html.vue"]]);export{X as default};
